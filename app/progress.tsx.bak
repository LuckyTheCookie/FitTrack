// ============================================================================
// PROGRESS SCREEN - Streak, Stats, Graphiques
// ============================================================================

import React, { useMemo } from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import Svg, { Rect, Text as SvgText, Path, Circle, Line } from 'react-native-svg';
import { 
  GlassCard, 
  SectionHeader, 
  BadgeWithProgress,
  EmptyState,
} from '../src/components/ui';
import { useAppStore } from '../src/stores';
import { getBadgesWithState, BADGE_DEFINITIONS } from '../src/utils/badges';
import { Colors, Spacing, FontSize, FontWeight, BorderRadius } from '../src/constants';
import type { Badge, MeasureEntry, HomeWorkoutEntry } from '../src/types';

export default function ProgressScreen() {
  const { 
    entries,
    settings,
    unlockedBadges,
    getStreak,
    getMonthlyStats,
    getSportEntries,
  } = useAppStore();

  const streak = getStreak();
  const monthlyStats = getMonthlyStats();
  const sportEntries = getSportEntries();

  // Filtrer pour afficher seulement les mois avec au moins une activitÃ©
  const relevantMonths = useMemo(() => 
    monthlyStats.filter(stat => stat.count > 0).slice(-6),
    [monthlyStats]
  );

  // Stats - on les calcule en premier pour les utiliser dans badgeProgress
  const totalWorkouts = sportEntries.length;
  const totalRuns = sportEntries.filter(e => e.type === 'run').length;
  const totalHomeWorkouts = sportEntries.filter(e => e.type === 'home').length;
  const totalDistance = sportEntries
    .filter(e => e.type === 'run')
    .reduce((sum, e) => sum + (e.type === 'run' ? e.distanceKm : 0), 0);

  // Badges avec Ã©tat
  const badges = useMemo(() => getBadgesWithState(unlockedBadges), [unlockedBadges]);

  // Calcul de la progression des badges
  const badgeProgress = useMemo(() => {
    const progressMap: Record<string, { current: number; target: number; label: string }> = {};
    
    // First Workout (1er entraÃ®nement)
    if (!badges.find(b => b.id === 'first_workout')?.unlockedAt) {
      progressMap['first_workout'] = { current: totalWorkouts, target: 1, label: `${totalWorkouts}/1 entraÃ®nements` };
    }
    
    // Streak 7 (7 jours de suite)
    if (!badges.find(b => b.id === 'streak_7')?.unlockedAt) {
      progressMap['streak_7'] = { current: streak.current, target: 7, label: `${streak.current}/7 jours de suite` };
    }
    
    // Streak 30 (30 jours de suite)
    if (!badges.find(b => b.id === 'streak_30')?.unlockedAt) {
      progressMap['streak_30'] = { current: streak.current, target: 30, label: `${streak.current}/30 jours de suite` };
    }
    
    // Workouts 10 (10 sÃ©ances)
    if (!badges.find(b => b.id === 'workouts_10')?.unlockedAt) {
      progressMap['workouts_10'] = { current: totalWorkouts, target: 10, label: `${totalWorkouts}/10 sÃ©ances` };
    }
    
    // Workouts 50 (50 sÃ©ances)
    if (!badges.find(b => b.id === 'workouts_50')?.unlockedAt) {
      progressMap['workouts_50'] = { current: totalWorkouts, target: 50, label: `${totalWorkouts}/50 sÃ©ances` };
    }

    // Workouts 100 (100 sÃ©ances)
    if (!badges.find(b => b.id === 'workouts_100')?.unlockedAt) {
      progressMap['workouts_100'] = { current: totalWorkouts, target: 100, label: `${totalWorkouts}/100 sÃ©ances` };
    }
    
    // Runner 10km
    if (!badges.find(b => b.id === 'runner_10km')?.unlockedAt) {
      progressMap['runner_10km'] = { current: totalDistance, target: 10, label: `${totalDistance.toFixed(1)}/10 km` };
    }
    
    // Runner 50km (Marathon)
    if (!badges.find(b => b.id === 'runner_50km')?.unlockedAt) {
      progressMap['runner_50km'] = { current: totalDistance, target: 50, label: `${totalDistance.toFixed(1)}/50 km` };
    }
    
    return progressMap;
  }, [badges, sportEntries, entries, streak, totalWorkouts, totalDistance]);

  // DerniÃ¨res mesures de poids
  const weightHistory = useMemo(() => {
    return entries
      .filter((e): e is MeasureEntry => e.type === 'measure' && e.weight !== undefined)
      .slice(0, 10)
      .reverse();
  }, [entries]);

  // TOP EXERCICE DU MOIS
  const topExercise = useMemo(() => {
    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM
    const monthWorkouts = entries.filter(
      (e): e is HomeWorkoutEntry => e.type === 'home' && e.date.startsWith(currentMonth)
    );
    
    const exerciseCounts: Record<string, number> = {};
    monthWorkouts.forEach(workout => {
      const lines = workout.exercises.split('\n');
      lines.forEach(line => {
        const match = line.match(/^([^:]+):/);
        if (match) {
          const name = match[1].trim().toLowerCase();
          exerciseCounts[name] = (exerciseCounts[name] || 0) + 1;
        }
      });
    });

    const sorted = Object.entries(exerciseCounts).sort((a, b) => b[1] - a[1]);
    return sorted.length > 0 ? { name: sorted[0][0], count: sorted[0][1] } : null;
  }, [entries]);

  // CALENDRIER DU MOIS (jours avec activitÃ©)
  const calendarData = useMemo(() => {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startDayOfWeek = (firstDay.getDay() + 6) % 7; // Lundi = 0
    
    const monthStr = now.toISOString().slice(0, 7);
    const activeDays = new Set(
      sportEntries
        .filter(e => e.date.startsWith(monthStr))
        .map(e => parseInt(e.date.slice(8, 10), 10))
    );
    
    return {
      daysInMonth,
      startDayOfWeek,
      activeDays,
      monthName: now.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' }),
    };
  }, [sportEntries]);

  // Graphique simple des sÃ©ances par semaine (6 derniÃ¨res semaines)
  const weeklyWorkoutsData = useMemo(() => {
    return relevantMonths.map(stat => ({
      label: stat.month.slice(5), // MM
      value: stat.count,
    }));
  }, [relevantMonths]);

  const maxValue = Math.max(...weeklyWorkoutsData.map(d => d.value), 1);

  return (
    <SafeAreaView style={styles.container} edges={['top']}>
      <ScrollView 
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        showsVerticalScrollIndicator={false}
      >
        <Text style={styles.screenTitle}>Progress</Text>

        {/* STREAK CARD */}
        <GlassCard variant="teal" style={styles.streakCard}>
          <View style={styles.streakMain}>
            <Text style={styles.streakEmoji}>ðŸ”¥</Text>
            <View>
              <Text style={styles.streakLabel}>Streak actuel</Text>
              <Text style={styles.streakNumber}>
                {streak.current} {streak.current > 1 ? 'jours' : 'jour'}
              </Text>
            </View>
          </View>
          <View style={styles.streakBest}>
            <Text style={styles.streakBestLabel}>Meilleur</Text>
            <Text style={styles.streakBestValue}>{streak.best}</Text>
          </View>
        </GlassCard>

        {/* STATS OVERVIEW */}
        <GlassCard style={styles.section}>
          <SectionHeader title="Statistiques globales" />
          <View style={styles.statsGrid}>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{totalWorkouts}</Text>
              <Text style={styles.statLabel}>SÃ©ances totales</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{totalHomeWorkouts}</Text>
              <Text style={styles.statLabel}>Maison</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{totalRuns}</Text>
              <Text style={styles.statLabel}>Courses</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{totalDistance.toFixed(1)}</Text>
              <Text style={styles.statLabel}>km parcourus</Text>
            </View>
          </View>
        </GlassCard>

        {/* TOP EXERCICE DU MOIS */}
        {topExercise && (
          <GlassCard style={styles.section}>
            <SectionHeader title="ðŸ† Top exercice du mois" />
            <View style={styles.topExerciseContainer}>
              <Text style={styles.topExerciseName}>{topExercise.name}</Text>
              <Text style={styles.topExerciseCount}>
                {topExercise.count} {topExercise.count > 1 ? 'fois' : 'fois'}
              </Text>
            </View>
          </GlassCard>
        )}

        {/* CALENDRIER DU MOIS */}
        <GlassCard style={styles.section}>
          <SectionHeader title={`ðŸ“… ${calendarData.monthName}`} />
          <View style={styles.calendarContainer}>
            <View style={styles.weekDays}>
              {['L', 'M', 'M', 'J', 'V', 'S', 'D'].map((day, i) => (
                <Text key={i} style={styles.weekDay}>{day}</Text>
              ))}
            </View>
            <View style={styles.calendarGrid}>
              {/* Empty cells for days before the 1st */}
              {Array.from({ length: calendarData.startDayOfWeek }).map((_, i) => (
                <View key={`empty-${i}`} style={styles.calendarDay} />
              ))}
              {/* Days of the month */}
              {Array.from({ length: calendarData.daysInMonth }).map((_, i) => {
                const day = i + 1;
                const isActive = calendarData.activeDays.has(day);
                const isToday = day === new Date().getDate();
                return (
                  <View 
                    key={day} 
                    style={[
                      styles.calendarDay,
                      isActive && styles.calendarDayActive,
                      isToday && styles.calendarDayToday,
                    ]}
                  >
                    <Text style={[
                      styles.calendarDayText,
                      isActive && styles.calendarDayTextActive,
                    ]}>
                      {day}
                    </Text>
                    {isActive && <Text style={styles.calendarCheck}>âœ“</Text>}
                  </View>
                );
              })}
            </View>
          </View>
        </GlassCard>

        {/* GRAPHIQUE SÃ‰ANCES PAR MOIS */}
        <GlassCard style={styles.section}>
          <SectionHeader title="SÃ©ances par mois" />
          {weeklyWorkoutsData.length > 0 ? (
            <View style={styles.chartContainer}>
              <Svg width="100%" height={120} viewBox="0 0 300 120">
                {weeklyWorkoutsData.map((data, index) => {
                  const barWidth = 35;
                  const gap = (300 - weeklyWorkoutsData.length * barWidth) / (weeklyWorkoutsData.length + 1);
                  const x = gap + index * (barWidth + gap);
                  const barHeight = (data.value / maxValue) * 80;
                  const y = 90 - barHeight;
                  
                  return (
                    <React.Fragment key={index}>
                      <Rect
                        x={x}
                        y={y}
                        width={barWidth}
                        height={barHeight}
                        rx={8}
                        fill={Colors.cta}
                        opacity={0.8}
                      />
                      <SvgText
                        x={x + barWidth / 2}
                        y={105}
                        fontSize="10"
                        fill="rgba(255,255,255,0.6)"
                        textAnchor="middle"
                      >
                        {data.label}
                      </SvgText>
                      <SvgText
                        x={x + barWidth / 2}
                        y={y - 5}
                        fontSize="11"
                        fill={Colors.text}
                        textAnchor="middle"
                        fontWeight="600"
                      >
                        {data.value}
                      </SvgText>
                    </React.Fragment>
                  );
                })}
              </Svg>
            </View>
          ) : (
            <EmptyState 
              icon="ðŸ“Š" 
              title="Pas encore de donnÃ©es" 
              subtitle="Commence Ã  t'entraÃ®ner !"
            />
          )}
        </GlassCard>

        {/* Ã‰VOLUTION DU POIDS - COURBE */}
        {weightHistory.length >= 2 && (
          <GlassCard style={styles.section}>
            <SectionHeader title="ðŸ“ˆ Ã‰volution du poids" />
            <View style={styles.weightChartContainer}>
              {(() => {
                const data = weightHistory.slice(-7);
                const weights = data.map(d => d.weight!);
                const minWeight = Math.min(...weights) - 1;
                const maxWeight = Math.max(...weights) + 1;
                const range = maxWeight - minWeight || 1;
                const width = 280;
                const height = 100;
                const padding = 10;
                
                const points = data.map((d, i) => {
                  const x = padding + (i / (data.length - 1)) * (width - 2 * padding);
                  const y = height - padding - ((d.weight! - minWeight) / range) * (height - 2 * padding);
                  return { x, y, weight: d.weight, date: d.date };
                });
                
                const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
                
                return (
                  <Svg width="100%" height={140} viewBox={`0 0 ${width} 140`}>
                    {/* Ligne de tendance */}
                    <Path
                      d={pathD}
                      stroke={Colors.cta}
                      strokeWidth={3}
                      fill="none"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                    {/* Points */}
                    {points.map((p, i) => (
                      <React.Fragment key={i}>
                        <Circle cx={p.x} cy={p.y} r={6} fill={Colors.cta} />
                        <Circle cx={p.x} cy={p.y} r={4} fill={Colors.cardSolid} />
                        <SvgText
                          x={p.x}
                          y={p.y - 12}
                          fontSize="10"
                          fill={Colors.text}
                          textAnchor="middle"
                          fontWeight="600"
                        >
                          {p.weight}
                        </SvgText>
                      </React.Fragment>
                    ))}
                    {/* Min/Max labels */}
                    <SvgText x={5} y={height - 5} fontSize="9" fill={Colors.muted}>
                      {minWeight.toFixed(1)} kg
                    </SvgText>
                    <SvgText x={5} y={15} fontSize="9" fill={Colors.muted}>
                      {maxWeight.toFixed(1)} kg
                    </SvgText>
                  </Svg>
                );
              })()}
            </View>
            <View style={styles.weightSummary}>
              <Text style={styles.weightSummaryText}>
                DerniÃ¨re mesure : {weightHistory[weightHistory.length - 1]?.weight} kg
              </Text>
            </View>
          </GlassCard>
        )}

        {/* BADGES */}
        <View style={styles.section}>
          <SectionHeader title="Badges" />
          <View style={styles.badgesList}>
            {badges.map((badge) => {
              const progress = badgeProgress[badge.id];
              const progressPercent = progress ? (progress.current / progress.target) * 100 : undefined;
              const progressLabel = progress ? progress.label : undefined;
              
              return (
                <BadgeWithProgress 
                  key={badge.id} 
                  badge={badge}
                  currentProgress={progressPercent}
                  progressLabel={progressLabel}
                />
              );
            })}
          </View>
        </View>

        {/* OBJECTIF HEBDO */}
        <GlassCard style={styles.section}>
          <SectionHeader title="Objectif hebdomadaire" />
          <View style={styles.goalInfo}>
            <Text style={styles.goalValue}>{settings.weeklyGoal}</Text>
            <Text style={styles.goalLabel}>sÃ©ances / semaine</Text>
          </View>
        </GlassCard>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.bg,
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: Spacing.lg,
    paddingBottom: 100,
  },
  screenTitle: {
    fontSize: FontSize.xxxl,
    fontWeight: FontWeight.extrabold,
    color: Colors.text,
    marginBottom: Spacing.lg,
  },
  streakCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  streakMain: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  streakEmoji: {
    fontSize: 40,
  },
  streakLabel: {
    fontSize: FontSize.sm,
    color: 'rgba(255, 255, 255, 0.72)',
  },
  streakNumber: {
    fontSize: FontSize.xxxl,
    fontWeight: FontWeight.bold,
    color: Colors.text,
  },
  streakBest: {
    alignItems: 'center',
  },
  streakBestLabel: {
    fontSize: FontSize.xs,
    color: 'rgba(255, 255, 255, 0.60)',
  },
  streakBestValue: {
    fontSize: FontSize.xxl,
    fontWeight: FontWeight.bold,
    color: Colors.text,
  },
  section: {
    marginTop: Spacing.lg,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  statItem: {
    flex: 1,
    minWidth: '45%',
    backgroundColor: Colors.overlay,
    borderRadius: BorderRadius.md,
    padding: Spacing.md,
    alignItems: 'center',
  },
  statValue: {
    fontSize: FontSize.xxxl,
    fontWeight: FontWeight.bold,
    color: Colors.text,
  },
  statLabel: {
    fontSize: FontSize.sm,
    color: Colors.muted,
    marginTop: 4,
  },
  chartContainer: {
    marginTop: Spacing.sm,
  },
  topExerciseContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'rgba(251, 191, 36, 0.15)',
    padding: Spacing.lg,
    borderRadius: BorderRadius.md,
  },
  topExerciseName: {
    fontSize: FontSize.xl,
    fontWeight: FontWeight.bold,
    color: Colors.text,
    textTransform: 'capitalize',
  },
  topExerciseCount: {
    fontSize: FontSize.lg,
    color: Colors.cta,
    fontWeight: FontWeight.semibold,
  },
  calendarContainer: {
    marginTop: Spacing.sm,
  },
  weekDays: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  weekDay: {
    flex: 1,
    textAlign: 'center',
    fontSize: FontSize.xs,
    color: Colors.muted,
    fontWeight: FontWeight.semibold,
  },
  calendarGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  calendarDay: {
    width: '14.28%',
    aspectRatio: 1,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  calendarDayActive: {
    backgroundColor: 'rgba(34, 197, 94, 0.20)',
    borderRadius: BorderRadius.sm,
  },
  calendarDayToday: {
    borderWidth: 2,
    borderColor: Colors.cta,
    borderRadius: BorderRadius.sm,
  },
  calendarDayText: {
    fontSize: FontSize.sm,
    color: Colors.muted,
  },
  calendarDayTextActive: {
    color: Colors.text,
    fontWeight: FontWeight.semibold,
  },
  calendarCheck: {
    position: 'absolute',
    bottom: 2,
    fontSize: 8,
    color: Colors.success,
  },
  weightChartContainer: {
    marginTop: Spacing.sm,
  },
  weightSummary: {
    marginTop: Spacing.sm,
    alignItems: 'center',
  },
  weightSummaryText: {
    fontSize: FontSize.sm,
    color: Colors.muted,
  },
  weightList: {
    gap: 8,
  },
  weightItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: Colors.stroke,
  },
  weightDate: {
    fontSize: FontSize.md,
    color: Colors.muted,
  },
  weightValue: {
    fontSize: FontSize.md,
    fontWeight: FontWeight.semibold,
    color: Colors.text,
  },
  badgesList: {
    gap: 12,
  },
  goalInfo: {
    flexDirection: 'row',
    alignItems: 'baseline',
    gap: 8,
  },
  goalValue: {
    fontSize: 48,
    fontWeight: FontWeight.bold,
    color: Colors.cta,
  },
  goalLabel: {
    fontSize: FontSize.lg,
    color: Colors.muted,
  },
});
